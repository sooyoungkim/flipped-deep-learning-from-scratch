##############################################################################
# 4.2.3 미니 배치 학습
#   - 배치용 교차 엔트로피 오차 구현
##############################################################################
import numpy as np
from dataset.mnist import load_mnist


def get_data():
    # 데이터 가져오기 : (훈련 이미지, 훈련 레이블), (시험 이미지, 시험 레이블)
    (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, flatten=True, one_hot_label=False)

    return x_train, t_train


x, t = get_data()
train_size = x.shape[0]     # 훈련 데이터 개수
print(train_size)           # 60000
print(np.shape(x))          # (60000, 784) = x.shape

batch_size = 10

# 배치로 사용할 데이터의 인덱스를 랜덤하게 구한다.
batch_mask = np.random.choice(train_size, batch_size)   # 0 이상 60,000 미만의 수 중에서 무작위로 batch_size(10개)만큼 추출
print(batch_mask)                                       # [13623 13317 10960 48807 36608 14118 59847 25378 55171 13199]

# 인덱스 배열로 한번에 여러 원소에 접근 가능 -> 미니배치 획득
x_batch = x[batch_mask]
t_batch = t[batch_mask]
print(x_batch)
# [[0. 0. 0. ... 0. 0. 0.]
#  [0. 0. 0. ... 0. 0. 0.]
#  [0. 0. 0. ... 0. 0. 0.]
#  ...
#  [0. 0. 0. ... 0. 0. 0.]
#  [0. 0. 0. ... 0. 0. 0.]
#  [0. 0. 0. ... 0. 0. 0.]]
print(t_batch)
# [8 1 8 5 8 5 7 8 6 5]

# 원-핫 인코딩일 경우
# [[0. 0. 0. 0. 0. 0. 1. 0. 0. 0.]
#  [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.]
#  [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
#  [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.]
#  [0. 0. 0. 0. 0. 0. 1. 0. 0. 0.]
#  [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]
#  [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
#  [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]
#  [0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
#  [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.]]



###################################
# 리스트를 zip 형태로
# y : 신경망 결과값(예측값),
# i : 처리할 데이터 수,
# t : 정답 레이블 (정답 인덱스 배열)
###################################
y = np.array([[3.30, 1.53, 9.90, 8.50, 4.01, 2.47, 6.88, 7.30, 6.81, 2.19],
              [2.25, 9.04, 6.09, 9.92, 7.91, 7.67, 1.25, 3.55, 2.92, 1.95],
              [4.87, 7.04, 7.31, 4.37, 9.70, 7.15, 2.91, 7.52, 5.95, 2.20],
              [6.24, 7.67, 1.24, 6.42, 1.26, 9.07, 2.74, 3.81, 8.62, 8.99],
              [4.28, 2.00, 2.54, 2.01, 5.59, 3.12, 9.96, 4.34, 6.37, 3.77]])
i = np.arange(5)    # [0 1 2 3 4]
t = np.array([2, 7, 0, 9, 4])

# [y[0,2], y[1,7], y[2,0], y[3,9], y[4,4]] 인 넘파이 배열을 생성!!!
z = y[i, t]
print(z)                    # [9.9  3.55 4.87 8.99 5.59]

y[i, t] -= 1
zz = y[i, t]
print(zz)                   # [8.9  2.55 3.87 7.99 4.59]

# 배치용 교차 엔트로피 오차
print(-np.sum(z + 1e-7))    # -32.9000005
